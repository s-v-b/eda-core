---
date: "`r Sys.time()`"
title: "LAB: Multiple Correspondance Analysis"


execute:
  echo: true
  eval: true
  collapse: true

format:
  html:
    output-file: lab-mca.html
  pdf:
    output-file: lab-mca.pdf


engine: knitr
---


```{r}
#| label: setup-packages
#| echo: true
#| collapse: true
#| message: false
#| warning: false
#| include: false

# We will use the following packages. 
# If needed, install them : pak::pkg_install(). 
stopifnot(
  require("testthat"),
  require("corrr"),
  require("magrittr"),
  require("lobstr"),
  require("sloop"),
  require("ggforce"),
  require("gt"),
  require("glue"),
  require("skimr"),
  require("patchwork"), 
  require("tidyverse"),
  require("ggfortify"),
  require("viridisLite")
  # require("autoplotly")
)
```

```{r}
#| label: setup-theme
#| message: false
#| warning: false
#| include: false
#| 
my_minimal_theme <- theme_minimal(
  base_size=9, 
  base_family = "Helvetica"
)

old_theme <- theme_set(
  my_minimal_theme               
  )

options(ggplot2.discrete.colour="viridis")
options(ggplot2.discrete.fill="viridis")
options(ggplot2.continuous.fill="viridis")
options(ggplot2.continuous.colour="viridis")
```


{{< include _preamble.qmd >}}



Besides the usual packages (`tidyverse`, ...),  we shall require 
`FactoMineR` and related packages.  

```{r}
#| message: false
#| warning: false
#| include: true
#| code-fold: true
#| 
stopifnot(
  require(FactoMineR),
  require(factoextra),
  require(FactoInvestigate)
)
```



Multiple sCorrespondence Analysis  
=========================


## The `mortality`  dataset

The goal is to investigate a possible link between age group and Cause of death.
We work with dataset `mortality`  from package `FactoMineR`

```{r}
#| echo: true
#| collapse: true
data("mortality", package = "FactoMineR")
```

```{r}
#| results: asis
#help(mortality)
```

>  A data frame with 62 rows (the different Causes of death) and 18 columns. Each column corresponds to an age interval (15-24, 25-34, 35-44, 45-54, 55-64, 65-74, 75-84, 85-94, 95 and more) in a year. The 9 first columns correspond to data in 1979 and the 9 last columns to data in 2006. In each cell, the counts of deaths for a Cause of death in an age interval (in a year) is given.

Source
: [Centre d'épidemiologie sur les Causes  de décès médicales](https://www.cepidc.inserm.fr)

See also EuroStat:

- [Causes of death (hlth_cdeath)  Reference Metadata in Single Integrated Metadata Structure (SIMS)](https://ec.europa.eu/eurostat/cache/metadata/en/hlth_cdeath_sims.htm)
- 

::: {.callout-note}

### Question

Read the documentation of the `mortality` dataset. Is this a sample? an aggregated  dataset?

If you consider `mortality` as an agregated dataset, can you figure out the organization  of the sample `mortality` was built from?  

:::

::::: {.content-visible when-profile="solution"}  


::: {.callout-tip title='Solution'} 
 
 
The `mortality` dataset is an *aggregated* dataset. It has been built from two samples. 
Each sample was built from the collection of *death certificates* from one calendar 
year in France (years 1999 and 2006). From each death certificate, two categorical pieces of information were extracted: *age group* of the deceased and a *Cause of death*. Each sample 
was then grouped by *age group*  and *Cause of death* and counts were computed. This defines a
two-ways *contingency table* in *long* form. The contingency table in *wide* form is obtained by pivoting: pick column names from column *age group* and values from counts. Column *Cause of depth* provide row names.

The final form of the dataset is obtained by concatenating the two contingency tables along the second axis. 

```{r}
mortality <- mortality |> 
    mutate(Cause = rownames(mortality)) |>
    mutate(Cause = factor(Cause)) |>
    relocate(Cause)
```

```{r}
my_gt <- function(gt_tbl){
  gt_tbl |>
  tab_style(
    style = list(
      "font-variant: small-caps;"
    ),
    locations = cells_body(columns = Cause)
  ) |>
  gt::cols_align(
    align="left",
    columns=Cause
  ) 

}
```

```{r}
mortality |>
    select(Cause, ends_with('(06)')) |> 
    sample_n(10) |>
    gt::gt() |>
    my_gt()
```

:::

:::::

## Elementary statistics and table wrangling


Before proceeding to Correspondence  Analysis (CA), let us tidy up the table and draw some elementary plots. 

::: {.callout-note  title="Question"}

- Start by partially *pivoting* `mortality`, so as to obtain a tibble with columns `Cause`, `year`, while keeping all columns named after age groups (tidy up the data so as to obtain a tibble in partially long format). 
- Use `rowwise()` and `sum(c_cross())` so as to compute the total number of deaths per `year` and `Cause`  in column `total`. This allows to mimic `rowSums()` inside a pipeline. Column `grand_total` is computed using a *window* function over grouping by `Cause`. 

:::

::: {.content-visible when-profile='solution'} 
 
::: {.callout-tip title='Solution'} 
 
```{r}
mortality_long <- mortality  |> 
  pivot_longer(
    cols=-Cause,
    cols_vary="slowest",
    names_to=c(".value", "year"),
    names_pattern="([\\w\\- ]*) \\(([0-9]{2})\\)"
  )  |> 
  mutate(year=ifelse(year=='06', 2006, 1979)) |> 
  rowwise() |> 
  mutate(total_year=sum(c_across(-c(Cause, year)))) |> 
  group_by(Cause) |> 
  mutate(grand_total = sum(total_year)) |> 
  ungroup()
```

```{r}
mortality_long |>
 slice_sample(n=10) |>
 gt::gt() |>
 my_gt() |>
 gt::tab_caption("A sample of rows from Mortality table in long form")
```

:::


::: {.callout-tip title='Solution'} 
 
A truly tidy version of the dataset can be obtained from further pivoting.

```{r}
mortality_tidy <- mortality_long |> 
  pivot_longer(
    cols=-c(year,Cause,total_year, grand_total),
    cols_vary="slowest",
    names_to=c("age_range"),
    values_to=c("#deaths")
) |>
  mutate(age_range = factor(age_range, levels=sort(unique(age_range)),ordered=T))
```

```{r}
mortality_tidy |>
  sample_n(5) |>
  gt::gt()
```
:::

:::


::: {.callout-note title='Question'} 
 
Build a bar plot to display the importance of Causes of deaths in France in years 1979 and 2006

:::

::: {.content-visible when-profile='solution'} 
 
::: {.callout-tip title='Solution'} 
 
 
```{r}
th <- theme_get()
(
mortality_long |> 
  mutate(Cause=fct_reorder(Cause, desc(grand_total))) |>
  mutate(year=as_factor(year)) |>
  ggplot() +
  scale_fill_discrete() +
  aes(x=Cause, 
      y=total_year, 
      fill=year) +
  geom_col(position=position_dodge()) +
  theme(
    legend.position="none",
    axis.text.x=element_blank(), #remove x axis labels
    axis.ticks.x=element_blank(), #remove x axis ticks
  ) +
  labs(
    title = "Causes of death, France, 1979, 2006",
    subtitle= "Raw counts"
  ) +
  xlab(label=NULL)
) |>
  plotly::ggplotly()  

oth <- theme_set(th)
```

:::
:::


::: {.callout-note title='Question'} 
 
Compute and display the total number of deaths in France in years 1979 and 2006.

:::


::: {.content-visible when-profile='solution'} 
 
::: {.callout-tip title='Solution'} 
 
```{r}
mortality_long |> 
  group_by(year) |> 
  summarise(total_deaths = sum(total_year)) |>
  gt::gt() |>
  gt::cols_label(
    year= "Year", 
    total_deaths = "#Deaths") |>
  gt::tab_caption("Mortality in France")
```

::: 
:::






::: {.callout-note title="Question"}

Compute the marginal counts for each year (1979, 2006). Compare. 

:::

::::: {.content-visible when-profile="solution"}  

::: {.callout-tip title='Solution'} 
 
Counts have already been computed above. 

```{r}
mortality_long |> 
  select(Cause, year, total_year, grand_total) |> 
  pivot_wider(
    id_cols=c(Cause, grand_total), 
    names_from = year, 
    values_from = total_year) |> 
  rename(Total=grand_total) |> 
  arrange(desc(Total)) |>
  gt::gt() |>
  my_gt()
```
 
:::

:::::




## Multiple Correspondance Analysis


::: {.callout-important}

### MCA executive summary

The input of multiple correspondence analysis is a data frame $X$ with $n$ rows and $p$ categorical columns. Multiple Correspondence Analysis starts by building the *indicator matrix*. The indicator matrix is built by *one-hot encoding* of each categorical variable.


- A categorical variable $V_j$ (factor) with $q$ levels is mapped to $q$ $\{0,1\}$ -valued variables $V_{j,r}$ for $r \leq q$

- If levels are indexed by $\{1, \ldots, q\}$, if the value of the categorical variable $V_j$ from row $i$  is $k \in \{1, \ldots, q\}$, the bina$
$$k \mapsto \underbrace{0,\ldots, 0}_{k-1}, 1, \underbrace{0, \ldots, 0}_{q-k}$$

- The indicator matrix has as many rows as the data matrix

- The number of columns of the indicator matrix is the sum of the number of levels of the categorical variables/columns of the data matrix

- The indicator matrix is a numerical matrix. It is suitable for factorial methodss


Recall $X$ is the data matrix with $n$ rows (individuals) and $p$ categorical columns (variables)

For $j \in \{1, \ldots, p\}$, let $J_j$ denote the number of levels(categories) of variable $j$

Let $q = \sum_{j\leq p} J_j$ be the sum of the number of levels throughout the variables


Let $Z$ be the incidence matrix with $n$ rows and $q$ columns

For $j\leq p$ and $k \leq J_j$, let $\langle j, k\rangle = \sum_{j'<j} J_{j'}+k$

Let $N = n \times p = \sum_{i\leq n} \sum_{j \leq p} X_{i,j}$ and
$$P = \frac{1}{N} Z$$

(the _correspondence matrix_ for MCA)

{{< fa hand-point-right >}} The row wise  sums of correspondence matrix $P$ are all equal to $1/n=p/N$

The column wise sum of the correspondence matrix $P$ for the $k$th level of the $j$th variable of $X$ ( $j \leq p$ ) is
$$N_{\langle j,k\rangle}/N = f_{\langle j,k\rangle}/p$$

where $f_{\langle j,k\rangle}$ stands for the relative frequency of level $k$ of the $j$th variable

$$D_r = \frac{1}{n}\text{Id}_n\qquad D_c =\text{diag}\left(\frac{f_{\langle j,k\rangle}}{p}\right)_{j \leq p, k\leq J_j}$$

In MCA, we compute the SVD $U \times D \times V^T$ of the standardized residuals matrix:

$$S = D_r^{-1/2}\times \left(P - r\times c^T\right) \times D_c^{-1/2} = \sqrt{n}\left(P - r\times c^T\right) \times D_c^{-1/2}$$

Coefficient $i, \langle j, k\rangle$  of $S$ is
$$\frac{\mathbb{I}_{i, \langle j, k\rangle}- f_{\langle j,k\rangle}}{\sqrt{n f_{\langle j,k\rangle}/p}}$$
   
   



MCA consists in computing the SVD of the standardized residuals matrix $S =  U  \times D \times V^\top$

From the SVD, we get

- $D_r^{-1/2} \times U$ *standardized coordinates of rows*
- $D_c^{-1/2} \times V$ *standardized coordinates of columns*
- $D_r^{-1/2} \times U \times D$ *principal coordinates of rows*
- $D_c^{-1/2} \times V \times D$ *principal coordinates of columns*
- Squared singular values: the principal *inertia*


When calling `svd(.)`, the argument should be
$$D_r^{1/2}\times \left(D_r^{-1} \times P \times D_c^{-1}- \mathbf{I}\times \mathbf{I}^\top  \right)\times D_c^{1/2}= D_r^{-1/2}\times \left( P - r \times c^\top  \right)\times D_c^{-1/2}$$


:::


::: {.callout-important}


### MCA and extended SVD

As
$$D_r^{-1} \times P \times D_c^{-1} - \mathbf{I}\mathbf{I}^\top = (D_r^{-1/2} \times U)\times D \times (D_c^{-1/2}\times V)^\top$$

$(D_r^{-1/2} \times U)\times D \times (D_c^{-1/2}\times V)^\top$ is the _extended SVD_ of
$$D_r^{-1} \times P \times D_c^{-1} - \mathbf{I}\mathbf{I}^\top$$
with respect to $D_r$ and $D_c$


:::

::: {.callout-note}

### Question

Perform CA on the two contingency tables. 

:::

::: {.callout-tip}

You may use `FactoMineR::MCA()`. It is interesting to compute the correspondence analysis in your own way, by preparing the matrix that is handled to `svd()` and returning 
a named list containing all relevant information. 

> Do the Jedi and Sith build their own light sabers? Jedi do. It's a key part of the religion to have a kyber crystal close to you, to build the saber through the power of the force creating a blade unique and in tune with them

{{< fa jedi >}}

:::

::::: {.content-visible when-profile="solution"}  

::: {.callout-tip title='Solution'} 
 
 
```{r}

```



:::

:::::

::: {.callout-note}

### Question

If you did use `FactoMineR::MCA()`, explain the organization of the result.

:::

::::: {.content-visible when-profile="solution"}  

::: {.callout-tip title='Solution'} 
 
The result of `FactoMineR::MCA(...)` is a named and nested list with five elements:

`eig`
: a matrix/array containing enough information to build a screeplot.

`call`
: a list of 9, containing the call to `CA()`, an object of type `language`, telling (in principle) the user how `CA()` was called. However, this is a *quoted expression*. Here we need to guess the value of `y` in the calling environment understand what's going on. 

```{r}
lst_ca[[1]]$call$call
```
Element `call` also contains the table margin distributions `marge.col` and `marge.row`. The truncation rank `ncp` (number of components) can be assigned before computing the SVD (default value is 5). Element $X$ stores the contingency table that was effectively used for computing Correpondence Analysis. 

`row`
: Information gathered from SVD to facilitate row profiles analysis. 

`col`
: a list structured in the same way as element `row`. Used for column profiles analysis

`svd`
: a list of 3, just as the resuld of `svd()` containing the singular values, the left and right singular vectors of matrix $...$



### Output of  `print(res.mca)`
   

   
|   | Name   |             Description                                          |
|:-:|:------------------------|:----------------------------------------------------|
|1  |   "$eig"                |"eigenvalues"                                        |
|2  |   "$var"                |"results for the variables"                          |
|3  |   "$var$coord"          |"coord. of the categories"                           |
|4  |   "$var$cos2"           |"cos2 for the categories"                           |
|5  |   "$var$contrib"        |"contributions of the categories"                    |
|6  |   "$var$v.test"         |"v-test for the categories"                          |
|7  |   "$ind"                |"results for the individuals"                        |
|8  |   "$ind$coord"          |"coord. for the individuals"                         |
|9  |   "$ind$cos2"          |"cos2 for the individuals"                          |
|10 |   "$ind$contrib"        |"contributions of the individuals"                   |
|11 |  "$quali.sup"          |"results for the supplementary categorical variables"|
|12 |  "$quali.sup$coord"    |"coord. for the supplementary categories"            |
|13 |  "$quali.sup$cos2"     |"cos2 for the supplementary categories"              |
|14 |  "$quali.sup$v.test"   |"v-test for the supplementary categories"            |
|15 |  "$call"               |"intermediate results"                               |
|16 |  "$call$marge.col"     |"weights of columns"                                 |
|17 |  "$call$marge.li"      |"weights of rows"                                    |

{{< fa exclamation-triangle >}}  `res.mca$svd` is not part of the output 

- `eig` is computed from the singular values in `res.mca$svd`

- `var` contains material for plotting information about categories and variables on factorial planes

- `ind` conatins material for plotting information about individuals on on factorial planes

???

:::

::: {.callout-warning}

In principle, all relevant information can be gathered from components `svd`, `call.marge.row`, and `call.marge.col`. 

:::

:::::


## Screeplots


::: {.callout-note}

### Question

Draw screeplots. Why are they useful? Comment briefly. 

:::

::::: {.content-visible when-profile="solution"}  

::: {.callout-tip title='Solution'} 
 
```{r}

```

:::

:::::


::::: {.content-visible when-profile="solution"}  

::: {.callout-tip title='Solution'} 
 
### Screeplot 

```{r}

```

:::


:::::

## Row profiles analysis


::: {.callout-note}

### Question 

Perform row profiles analysis.

What are the classical plots? How can you build them from the output of `FactoMiner::CA`? 

Build the table of row contributions (the so-called $\cos^2$)

:::

::::: {.content-visible when-profile="solution"}  

::: {.callout-tip title='Solution'} 

Attribute `row` of objects of class `MCA` (exported from `FactoMineR`) is the starting point of any 
row profiles analysis. 

```{r}

```

Attribute `row` is a named list made of $4$ components. 
:::


::: {.callout-tip title='Solution'} 
  
`coord`
: a matrix with named rows and columns. The number of rows of `coord` matches the number of rows of the contingency table (here, the number of possible death Causes). The number of columns matches the rank of the truncated SVD that underlies Correspondance Analysis. Here it is $5$ which also the rank of the standardized contingency table.

> The row principal coordinates are the principal coordinates of each row profile in terms of the principal component. 

The columns of `coord` are pairwise orthogonal in the inner product space defined by `diag(call$marge.row)` (which embodies the marginal probabilities of the so-called Causes of deaths)

```{r}

```

We can recover `row$coord` from the left singular vectors and the singular values:

```{r}

```


```{r}

```


:::


::: {.callout-tip title='Solution'} 


`inertia`
: a numerical vector with length matching the number of rows of `coord`, `contrib` and `cos2`. 

> Inertia is the way CA measures variation between row profiles. Total inertia is the $\chi^2$ statistic divided by sample size. 


Row inertia can be obtained by multiplying the row marginal probability by the squared Euclidean norm of 
the row in the principal coordinate matrix. 
 
```{r}

```

:::

::: {.callout-tip title='Solution'} 
 
`cos2`
: Coefficients of matrix `cos2` are the share of row inertia from the corresponding cell in `coord`


```{r}

```

:::

::: {.callout-tip title='Solution'} 
 
`contrib`
: 

Not too surprisingly, `coord`, `contrib`, and `cos2` share the same row names and column names.   


```{r}

```

The Row Profiles are the rows of matrix `R` below

```{r}

```

```{r}

```

:::


::: {.callout-tip title='Solution'} 
 
We can now display a scatterplot from component `coord`. This is called a *Row Plot*. 

```{r}

```
 
:::


::: {.callout-tip title='Solution'} 


```{r}

```

:::

:::::


::: {.callout-note title='Question'} 
 


:::

::::: {.content-visible when-profile="solution"}  

```{r}


```


:::::   



::: {.callout-note title='Question'} 
 
Perform  column profiles analysis

:::

::::: {.content-visible when-profile='solution'} 
 
```{r}

```

:::::


::::: {.content-visible when-profile="solution"}  

::: {.callout-tip title='Solution'} 


```{r}

```

```{r}

```

 
:::



:::::


## Symmetric plots 

::: {.callout-note title="Question"}

Build the symmetric plots (biplots)  for multiple correspondence analysis.


:::




::::: {.content-visible when-profile="solution"}  

::: {.content-visible when-profile='solution'} 
 
### From the shelf 

```{r}
#| eval: false

```

:::


::: {.callout-tip title='Solution'} 

### {{< fa jedi >}}

```{r}

```

:::

:::::

::: {.content-visible when-profile='solution'} 

::: {.callout-tip title='Solution'} 
 
It is convenient to use distinct color scales for  rows and columns. 

 
```{r}

```

:::

:::

## Mosaicplots

::: {.callout-note title="Question"}



:::





::::: {.content-visible when-profile="solution"}  

::: {.callout-tip title='Solution'} 
 
```{r}

```



:::

:::::


